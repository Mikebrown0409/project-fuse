//! RISC Zero zkVM proof generation and verification (1.0+ API)

use crate::error::{VceError, Result};
use crate::proof::JournalOutput;
use risc0_zkvm::{
    ExecutorEnv, ExecutorImpl, get_prover_server, ProverOpts, ProverServer, Receipt, VerifierContext,
};
use risc0_zkvm::serde::to_vec;
use risc0_binfmt::{MemoryImage, Program};
use bincode;
use std::rc::Rc;

/// Prover type selection for proof generation
/// 
/// Determines which hardware backend to use for proof generation.
/// GPU option provides significant performance improvements but requires additional setup.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ProverType {
    /// Local CPU prover (default, always available)
    Local,
    /// Local GPU prover (CUDA on NVIDIA, Metal on Apple Silicon)
    /// Requires GPU hardware and appropriate drivers
    /// Note: Requires --features gpu to be enabled at build time
    Gpu,
}

/// Get the guest program ELF binary
/// Returns None if the guest program hasn't been built yet
fn get_guest_elf() -> Option<&'static [u8]> {
    // Point directly to the workspace target directory (most reliable path)
    // This is where cargo build --target riscv32im-risc0-zkvm-elf places the binary
    #[cfg(guest_program_built)]
    {
        Some(include_bytes!("../../target/riscv32im-risc0-zkvm-elf/release/fuse-guest"))
    }
    
    #[cfg(not(guest_program_built))]
    {
        None
    }
}

/// Compute image ID from ELF binary for verification
/// The image ID is a cryptographic hash of the guest program and is used to verify
/// that proofs were generated by the expected code.
fn compute_image_id(elf: &[u8]) -> Result<risc0_zkvm::sha::Digest> {
    use risc0_zkvm_platform::{PAGE_SIZE, memory::GUEST_MAX_MEM};
    let program = Program::load_elf(elf, GUEST_MAX_MEM as u32)
        .map_err(|e| VceError::RiscZero(format!("Failed to load ELF binary: {e}. The ELF may be corrupted or not a valid RISC Zero guest program.")))?;
    let image = MemoryImage::new(&program, PAGE_SIZE as u32)
        .map_err(|e| VceError::RiscZero(format!("Failed to create memory image from ELF: {e}. This may indicate an issue with the guest program binary.")))?;
    Ok(image.compute_id())
}

/// Get prover server based on prover type
fn get_prover_for_type(prover_type: ProverType) -> Result<Rc<dyn ProverServer>> {
    let opts = match prover_type {
        ProverType::Local => {
            ProverOpts::default()
        }
        ProverType::Gpu => {
            #[cfg(feature = "gpu")]
            {
                // GPU acceleration is handled via feature flags in risc0-zkvm
                // The CUDA feature enables GPU support automatically
                ProverOpts::default()
            }
            #[cfg(not(feature = "gpu"))]
            {
                return Err(VceError::ProofGenerationFailed(
                    "GPU proving requested but 'gpu' feature is not enabled. Build with --features gpu".to_string()
                ));
            }
        }
    };
    
    get_prover_server(&opts)
        .map_err(|e| VceError::ProofGenerationFailed(format!("Failed to initialize RISC Zero prover server: {e}. Ensure RISC Zero toolchain is properly installed.")))
}

/// Generate a RISC Zero proof for a compliance check
/// 
/// # Arguments
/// * `spec_json` - JSON string of the compliance specification
/// * `system_data_json` - JSON string of the system data to verify
/// * `prover_type` - Type of prover to use (Local or Gpu)
/// 
/// # Returns
/// A tuple of (serialized receipt, `journal_output`, `journal_bytes`)
pub fn generate_proof(
    spec_json: &str,
    system_data_json: &str,
    prover_type: ProverType,
) -> Result<(Vec<u8>, JournalOutput, Vec<u8>)> {
    // Get guest program ELF binary
    let guest_elf = get_guest_elf().ok_or_else(|| {
        VceError::ProofGenerationFailed(
            "Guest program ELF binary not found. To build it, run: RUSTC=\"$HOME/.risc0/toolchains/v1.91.1-rust-aarch64-apple-darwin/bin/rustc\" cargo build -p fuse-guest --release --target riscv32im-risc0-zkvm-elf".to_string()
        )
    })?;
    
    // Prepare environment with inputs (1.0+ API: use .write_slice())
    let env = ExecutorEnv::builder()
        .write_slice(&to_vec(spec_json)
            .map_err(|e| VceError::InputSerialization(format!("Failed to serialize compliance spec to JSON: {e}")))?)
        .write_slice(&to_vec(system_data_json)
            .map_err(|e| VceError::InputSerialization(format!("Failed to serialize system data to JSON: {e}")))?)
        .build()
        .map_err(|e| VceError::GuestProgramExecution(format!("Failed to build executor environment: {e}. This may indicate an issue with input data format.")))?;
    
    // Execute the guest program
    let mut exec = ExecutorImpl::from_elf(env, guest_elf)
        .map_err(|e| VceError::GuestProgramExecution(format!("Failed to create executor from guest ELF: {e}. The guest program may be corrupted or incompatible.")))?;
    
    let session = exec.run()
        .map_err(|e| VceError::GuestProgramExecution(format!("Guest program execution failed: {e}. Check that inputs are valid JSON and guest program logic is correct.")))?;
    
    // Get prover server based on requested type
    // Note: Real proof generation can take 10-20+ minutes. Use RISC0_DEV_MODE=1 for faster testing.
    // GPU proving can reduce this significantly (5-10x faster).
    let prover = get_prover_for_type(prover_type)?;
    
    // Log prover type being used
    match prover_type {
        ProverType::Local => {
            println!("   Using local CPU prover");
        }
        ProverType::Gpu => {
            #[cfg(feature = "gpu")]
            println!("   Using local GPU prover (CUDA/Metal)");
            #[cfg(not(feature = "gpu"))]
            println!("   GPU prover requested but feature not enabled");
        }
    }
    
    // Generate proof (this is the computationally expensive step)
    let ctx = VerifierContext::default();
    let receipt = prover.prove_session(&ctx, &session)
        .map_err(|e| VceError::ProofGenerationFailed(format!("RISC Zero proof generation failed: {e}. This step can take 10-20+ minutes for real proofs. For testing, use RISC0_DEV_MODE=1.")))?;
    
    // Extract journal bytes (public outputs)
    let journal_bytes = receipt.receipt.journal.bytes.clone();
    
    // Extract output from journal using decode (1.0+ API)
    let journal_output: JournalOutput = receipt.receipt.journal.decode()
        .map_err(|e| VceError::RiscZero(format!("Failed to decode JournalOutput from journal: {e}. The guest program may not have committed the result correctly.")))?;
    
    // Serialize receipt for storage
    let receipt_bytes = bincode::serialize(&receipt.receipt)
        .map_err(|e| VceError::RiscZero(format!("Failed to serialize receipt for storage: {e}")))?;
    
    Ok((receipt_bytes, journal_output, journal_bytes))
}

/// Verify a RISC Zero proof
/// 
/// # Arguments
/// * `receipt_bytes` - Serialized RISC Zero receipt
/// 
/// # Returns
/// A tuple of (`journal_output`, `journal_bytes`) if verification succeeds
pub fn verify_proof(receipt_bytes: &[u8]) -> Result<(JournalOutput, Vec<u8>)> {
    // Deserialize receipt
    let receipt: Receipt = bincode::deserialize(receipt_bytes)
        .map_err(|e| VceError::ReceiptDeserialization(format!("Failed to deserialize receipt from bytes: {e}. The receipt data may be corrupted.")))?;
    
    // Get guest program ELF for image ID computation
    let guest_elf = get_guest_elf().ok_or_else(|| {
        VceError::ProofVerificationFailed(
            "Guest program ELF binary not found. Cannot verify proof without computing image ID. Build the guest program first.".to_string()
        )
    })?;
    
    // Compute image ID from ELF
    let image_id = compute_image_id(guest_elf)
        .map_err(|e| VceError::ProofVerificationFailed(format!("Failed to compute image ID from guest ELF: {e}. The ELF binary may be corrupted.")))?;
    
    // Verify the receipt (1.0+ API: verify takes image_id as Digest)
    if std::env::var("RISC0_DEV_MODE").unwrap_or_default() == "1" {
        println!("   âš  Skipping strict cryptographic verification in DEV_MODE");
    } else {
        receipt.verify(image_id)
            .map_err(|e| VceError::ProofVerificationFailed(format!("RISC Zero cryptographic proof verification failed: {e}. The proof may be invalid, tampered with, or generated by a different guest program version.")))?;
    }
    
    // Extract journal bytes
    let journal_bytes = receipt.journal.bytes.clone();
    
    // Extract output from journal using decode (1.0+ API)
    let journal_output: JournalOutput = receipt.journal.decode()
        .map_err(|e| VceError::RiscZero(format!("Failed to decode JournalOutput from verified journal: {e}. The journal format may be incorrect.")))?;
    
    Ok((journal_output, journal_bytes))
}
